// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Spice = require("@greenlabs/ppx-spice/src/rescript/Spice.js");
var Js_dict = require("rescript/lib/js/js_dict.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");

function t0_encode(v) {
  if (v === "A") {
    return ["A"];
  } else {
    return ["B"];
  }
}

function t0_decode(v) {
  if (!Array.isArray(v) && (v === null || typeof v !== "object") && typeof v !== "number" && typeof v !== "string" && typeof v !== "boolean") {
    return Spice.error(undefined, "Not a variant", v);
  }
  if (!Array.isArray(v)) {
    return Spice.error(undefined, "Not a variant", v);
  }
  if (v.length === 0) {
    return Spice.error(undefined, "Expected variant, found empty array", v);
  }
  var match = Belt_Array.getExn(v, 0);
  if (!(!Array.isArray(match) && (match === null || typeof match !== "object") && typeof match !== "number" && typeof match !== "string" && typeof match !== "boolean") && typeof match === "string") {
    switch (match) {
      case "A" :
          if (v.length !== 1) {
            return Spice.error(undefined, "Invalid number of arguments to variant constructor", v);
          } else {
            return {
                    TAG: "Ok",
                    _0: "A"
                  };
          }
      case "B" :
          if (v.length !== 1) {
            return Spice.error(undefined, "Invalid number of arguments to variant constructor", v);
          } else {
            return {
                    TAG: "Ok",
                    _0: "B"
                  };
          }
      default:
        
    }
  }
  return Spice.error(undefined, "Invalid variant constructor", Belt_Array.getExn(v, 0));
}

function t1_encode(v) {
  return Js_dict.fromArray(Spice.filterOptional([
                  [
                    "a",
                    false,
                    Spice.stringToJson(v.a)
                  ],
                  [
                    "b",
                    false,
                    Spice.intToJson(v.b)
                  ]
                ]));
}

function t1_decode(v) {
  if (!Array.isArray(v) && (v === null || typeof v !== "object") && typeof v !== "number" && typeof v !== "string" && typeof v !== "boolean") {
    return Spice.error(undefined, "Not an object", v);
  }
  if (!(typeof v === "object" && !Array.isArray(v))) {
    return Spice.error(undefined, "Not an object", v);
  }
  var a = Spice.stringFromJson(Belt_Option.getWithDefault(Js_dict.get(v, "a"), null));
  if (a.TAG === "Ok") {
    var b = Spice.intFromJson(Belt_Option.getWithDefault(Js_dict.get(v, "b"), null));
    if (b.TAG === "Ok") {
      return {
              TAG: "Ok",
              _0: {
                a: a._0,
                b: b._0
              }
            };
    }
    var e = b._0;
    return {
            TAG: "Error",
            _0: {
              path: ".b" + e.path,
              message: e.message,
              value: e.value
            }
          };
  }
  var e$1 = a._0;
  return {
          TAG: "Error",
          _0: {
            path: ".a" + e$1.path,
            message: e$1.message,
            value: e$1.value
          }
        };
}

function t2_encode(v) {
  return [
          Spice.stringToJson(v[0]),
          Spice.intToJson(v[1])
        ];
}

function t2_decode(v) {
  if (!Array.isArray(v) && (v === null || typeof v !== "object") && typeof v !== "number" && typeof v !== "string" && typeof v !== "boolean") {
    return Spice.error(undefined, "Not a tuple", v);
  }
  if (!Array.isArray(v)) {
    return Spice.error(undefined, "Not a tuple", v);
  }
  if (v.length !== 2) {
    return Spice.error(undefined, "Incorrect cardinality", v);
  }
  var v0 = v[0];
  var v1 = v[1];
  var match = Spice.stringFromJson(v0);
  var match$1 = Spice.intFromJson(v1);
  if (match.TAG === "Ok") {
    if (match$1.TAG === "Ok") {
      return {
              TAG: "Ok",
              _0: [
                match._0,
                match$1._0
              ]
            };
    }
    var e = match$1._0;
    return {
            TAG: "Error",
            _0: {
              path: "[1]" + e.path,
              message: e.message,
              value: e.value
            }
          };
  }
  var e$1 = match._0;
  return {
          TAG: "Error",
          _0: {
            path: "[0]" + e$1.path,
            message: e$1.message,
            value: e$1.value
          }
        };
}

exports.t0_encode = t0_encode;
exports.t0_decode = t0_decode;
exports.t1_encode = t1_encode;
exports.t1_decode = t1_decode;
exports.t2_encode = t2_encode;
exports.t2_decode = t2_decode;
/* No side effect */
