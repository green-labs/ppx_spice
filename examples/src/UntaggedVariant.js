// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

let Spice = require("@jfrolich/ppx-spice/src/rescript/Spice.js");
let Stdlib_Option = require("@rescript/runtime/lib/js/Stdlib_Option.js");

function t0_encode(v) {
  if (v === "A") {
    return ["A"];
  } else {
    return ["B"];
  }
}

function t0_decode(v) {
  if (!Array.isArray(v)) {
    return Spice.error(undefined, "Not a variant", v);
  }
  if (v.length === 0) {
    return Spice.error(undefined, "Expected variant, found empty array", v);
  }
  let match = v[0];
  if (typeof match === "string") {
    switch (match) {
      case "A" :
        if (v.length !== 1) {
          return Spice.error(undefined, "Invalid number of arguments to variant constructor", v);
        } else {
          return {
            TAG: "Ok",
            _0: "A"
          };
        }
      case "B" :
        if (v.length !== 1) {
          return Spice.error(undefined, "Invalid number of arguments to variant constructor", v);
        } else {
          return {
            TAG: "Ok",
            _0: "B"
          };
        }
    }
  }
  return Spice.error(undefined, "Invalid variant constructor", v[0]);
}

function t1_encode(v) {
  return Object.fromEntries(Spice.filterOptional([
    [
      "a",
      Spice.stringToJson(v.a)
    ],
    [
      "b",
      Spice.intToJson(v.b)
    ]
  ]));
}

function t1_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let a = Spice.stringFromJson(Stdlib_Option.getOr(v["a"], null));
  if (a.TAG === "Ok") {
    let b = Spice.intFromJson(Stdlib_Option.getOr(v["b"], null));
    if (b.TAG === "Ok") {
      return {
        TAG: "Ok",
        _0: {
          a: a._0,
          b: b._0
        }
      };
    }
    let e = b._0;
    return {
      TAG: "Error",
      _0: {
        path: ".b" + e.path,
        message: e.message,
        value: e.value
      }
    };
  }
  let e$1 = a._0;
  return {
    TAG: "Error",
    _0: {
      path: ".a" + e$1.path,
      message: e$1.message,
      value: e$1.value
    }
  };
}

function t2_encode(v) {
  return [
    Spice.stringToJson(v[0]),
    Spice.intToJson(v[1])
  ];
}

function t2_decode(v) {
  if (!Array.isArray(v)) {
    return Spice.error(undefined, "Not a tuple", v);
  }
  if (v.length !== 2) {
    return Spice.error(undefined, "Incorrect cardinality", v);
  }
  let v0 = v[0];
  let v1 = v[1];
  let match = Spice.stringFromJson(v0);
  let match$1 = Spice.intFromJson(v1);
  if (match.TAG === "Ok") {
    if (match$1.TAG === "Ok") {
      return {
        TAG: "Ok",
        _0: [
          match._0,
          match$1._0
        ]
      };
    }
    let e = match$1._0;
    return {
      TAG: "Error",
      _0: {
        path: "[1]" + e.path,
        message: e.message,
        value: e.value
      }
    };
  }
  let e$1 = match._0;
  return {
    TAG: "Error",
    _0: {
      path: "[0]" + e$1.path,
      message: e$1.message,
      value: e$1.value
    }
  };
}

exports.t0_encode = t0_encode;
exports.t0_decode = t0_decode;
exports.t1_encode = t1_encode;
exports.t1_decode = t1_decode;
exports.t2_encode = t2_encode;
exports.t2_decode = t2_decode;
/* No side effect */
