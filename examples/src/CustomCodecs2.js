// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

let Spice = require("@jfrolich/ppx-spice/src/rescript/Spice.js");
let Stdlib_Option = require("@rescript/runtime/lib/js/Stdlib_Option.js");
let Stdlib_Result = require("@rescript/runtime/lib/js/Stdlib_Result.js");

function address_encode(v) {
  return Object.fromEntries(Spice.filterOptional([
    [
      "street",
      Spice.stringToJson(v.street)
    ],
    [
      "number",
      Spice.intToJson(v.number)
    ]
  ]));
}

function address_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let street = Stdlib_Option.getOr(Stdlib_Option.map(v["street"], Spice.stringFromJson), Spice.error(undefined, "street" + " missing", v));
  if (street.TAG === "Ok") {
    let number = Stdlib_Option.getOr(Stdlib_Option.map(v["number"], Spice.intFromJson), Spice.error(undefined, "number" + " missing", v));
    if (number.TAG === "Ok") {
      return {
        TAG: "Ok",
        _0: {
          street: street._0,
          number: number._0
        }
      };
    }
    let e = number._0;
    return Spice.error("number", e.message, e.value);
  }
  let e$1 = street._0;
  return Spice.error("street", e$1.message, e$1.value);
}

function user_encode(v) {
  return Object.fromEntries(Spice.filterOptional([
    [
      "name",
      Spice.stringToJson(v.name)
    ],
    [
      "address",
      address_encode(v.address)
    ]
  ]));
}

function user_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let name = Stdlib_Option.getOr(Stdlib_Option.map(v["name"], Spice.stringFromJson), Spice.error(undefined, "name" + " missing", v));
  if (name.TAG === "Ok") {
    let address = Stdlib_Option.getOr(Stdlib_Option.map(v["address"], address_decode), Spice.error(undefined, "address" + " missing", v));
    if (address.TAG === "Ok") {
      return {
        TAG: "Ok",
        _0: {
          name: name._0,
          address: address._0
        }
      };
    }
    let e = address._0;
    return Spice.error("address", e.message, e.value);
  }
  let e$1 = name._0;
  return Spice.error("name", e$1.message, e$1.value);
}

function encoderUser(v) {
  return {
    name: v.name,
    address_street: v.address.street,
    address_number: v.address.number
  };
}

function decoderUser(json) {
  if (typeof json !== "object" || json === null || Array.isArray(json)) {
    return {
      TAG: "Error",
      _0: {
        path: "",
        message: "Expected Json Object",
        value: json
      }
    };
  }
  let name = json.name;
  if (typeof name === "string") {
    let street = json.address_street;
    if (typeof street === "string") {
      let number = json.address_number;
      if (typeof number === "number") {
        return {
          TAG: "Ok",
          _0: {
            name: name,
            address: {
              street: street,
              number: number | 0
            }
          }
        };
      }
    }
  }
  return {
    TAG: "Error",
    _0: {
      path: "",
      message: "Expected name, street, number ",
      value: json
    }
  };
}

let codecUser = [
  encoderUser,
  decoderUser
];

function data_encode(v) {
  return Object.fromEntries(Spice.filterOptional([[
      "user",
      encoderUser(v.user)
    ]]));
}

function data_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let user = Stdlib_Option.getOr(Stdlib_Option.map(v["user"], decoderUser), Spice.error(undefined, "user" + " missing", v));
  if (user.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: {
        user: user._0
      }
    };
  }
  let e = user._0;
  return Spice.error("user", e.message, e.value);
}

let data = {
  "user" : {
    "name": "woonki",
    "address_street": "Munjung",
    "address_number": 8
  }
};

let data$1 = data_decode(data);

let json = data_encode(Stdlib_Result.getOrThrow(data$1, undefined));

exports.address_encode = address_encode;
exports.address_decode = address_decode;
exports.user_encode = user_encode;
exports.user_decode = user_decode;
exports.encoderUser = encoderUser;
exports.decoderUser = decoderUser;
exports.codecUser = codecUser;
exports.data_encode = data_encode;
exports.data_decode = data_decode;
exports.data = data$1;
exports.json = json;
/* data Not a pure module */
