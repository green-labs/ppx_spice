// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

let Spice = require("@jfrolich/ppx-spice/src/rescript/Spice.js");
let Stdlib_Option = require("@rescript/runtime/lib/js/Stdlib_Option.js");
let Stdlib_Result = require("@rescript/runtime/lib/js/Stdlib_Result.js");

function status_encode(v) {
  switch (v) {
    case "WAITING" :
      return ["WAITING"];
    case "PROCESSING" :
      return ["PROCESSING"];
    case "SUCCESS" :
      return ["SUCCESS"];
    case "FAIL" :
      return ["FAIL"];
  }
}

function status_decode(v) {
  if (!Array.isArray(v)) {
    return Spice.error(undefined, "Not a variant", v);
  }
  if (v.length === 0) {
    return Spice.error(undefined, "Expected variant, found empty array", v);
  }
  let match = v[0];
  if (typeof match === "string") {
    switch (match) {
      case "FAIL" :
        if (v.length !== 1) {
          return Spice.error(undefined, "Invalid number of arguments to variant constructor", v);
        } else {
          return {
            TAG: "Ok",
            _0: "FAIL"
          };
        }
      case "PROCESSING" :
        if (v.length !== 1) {
          return Spice.error(undefined, "Invalid number of arguments to variant constructor", v);
        } else {
          return {
            TAG: "Ok",
            _0: "PROCESSING"
          };
        }
      case "SUCCESS" :
        if (v.length !== 1) {
          return Spice.error(undefined, "Invalid number of arguments to variant constructor", v);
        } else {
          return {
            TAG: "Ok",
            _0: "SUCCESS"
          };
        }
      case "WAITING" :
        if (v.length !== 1) {
          return Spice.error(undefined, "Invalid number of arguments to variant constructor", v);
        } else {
          return {
            TAG: "Ok",
            _0: "WAITING"
          };
        }
    }
  }
  return Spice.error(undefined, "Invalid variant constructor", v[0]);
}

function encoderStatus(v) {
  let tmp;
  switch (v) {
    case "WAITING" :
      tmp = "waiting";
      break;
    case "PROCESSING" :
      tmp = "processing";
      break;
    case "SUCCESS" :
      tmp = "success";
      break;
    case "FAIL" :
      tmp = "fail";
      break;
  }
  return tmp;
}

function decoderStatus(json) {
  if (typeof json !== "string") {
    return {
      TAG: "Error",
      _0: {
        path: "",
        message: "Expected Json String",
        value: json
      }
    };
  }
  switch (json) {
    case "fail" :
      return {
        TAG: "Ok",
        _0: "FAIL"
      };
    case "processing" :
      return {
        TAG: "Ok",
        _0: "PROCESSING"
      };
    case "success" :
      return {
        TAG: "Ok",
        _0: "SUCCESS"
      };
    case "waiting" :
      return {
        TAG: "Ok",
        _0: "WAITING"
      };
    default:
      return {
        TAG: "Error",
        _0: {
          path: "",
          message: "Unexpected status value: " + json,
          value: json
        }
      };
  }
}

let codecStatus = [
  encoderStatus,
  decoderStatus
];

function data_encode(v) {
  return Object.fromEntries(Spice.filterOptional([[
      "status",
      encoderStatus(v.status)
    ]]));
}

function data_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let status = Stdlib_Option.getOr(Stdlib_Option.map(v["status"], decoderStatus), Spice.error(undefined, "status" + " missing", v));
  if (status.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: {
        status: status._0
      }
    };
  }
  let e = status._0;
  return Spice.error("status", e.message, e.value);
}

let data = {
    "status": "success"
  };

let data$1 = data_decode(data);

let json = data_encode(Stdlib_Result.getOrThrow(data$1, undefined));

exports.status_encode = status_encode;
exports.status_decode = status_decode;
exports.encoderStatus = encoderStatus;
exports.decoderStatus = decoderStatus;
exports.codecStatus = codecStatus;
exports.data_encode = data_encode;
exports.data_decode = data_decode;
exports.data = data$1;
exports.json = json;
/* data Not a pure module */
