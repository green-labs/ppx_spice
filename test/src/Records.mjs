// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Spice from "./Spice.mjs";
import * as Stdlib_Option from "@rescript/runtime/lib/es6/Stdlib_Option.js";

function t_encode(v) {
  return Object.fromEntries(Spice.filterOptional([
    [
      "spice-label",
      Spice.stringToJson(v.label)
    ],
    [
      "spice-value",
      Spice.intToJson(v.value)
    ]
  ]));
}

function t_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let label = Stdlib_Option.getOr(Stdlib_Option.map(v["spice-label"], Spice.stringFromJson), Spice.error(undefined, "spice-label" + " missing", v));
  if (label.TAG === "Ok") {
    let value = Stdlib_Option.getOr(Stdlib_Option.map(v["spice-value"], Spice.intFromJson), Spice.error(undefined, "spice-value" + " missing", v));
    if (value.TAG === "Ok") {
      return {
        TAG: "Ok",
        _0: {
          label: label._0,
          value: value._0
        }
      };
    }
    let e = value._0;
    return Spice.error("spice-value", e.message, e.value);
  }
  let e$1 = label._0;
  return Spice.error("spice-label", e$1.message, e$1.value);
}

function t1_encode(v) {
  return Object.fromEntries(Spice.filterOptional([
    [
      "label",
      Spice.stringToJson(v.label)
    ],
    [
      "value",
      Spice.intToJson(v.value)
    ]
  ]));
}

function t1_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let label = Stdlib_Option.getOr(Stdlib_Option.map(v["label"], Spice.stringFromJson), Spice.error(undefined, "label" + " missing", v));
  if (label.TAG === "Ok") {
    let value = Stdlib_Option.getOr(Stdlib_Option.map(v["value"], Spice.intFromJson), Spice.error(undefined, "value" + " missing", v));
    if (value.TAG === "Ok") {
      return {
        TAG: "Ok",
        _0: {
          label: label._0,
          value: value._0
        }
      };
    }
    let e = value._0;
    return Spice.error("value", e.message, e.value);
  }
  let e$1 = label._0;
  return Spice.error("label", e$1.message, e$1.value);
}

function tOp_encode(v) {
  let extra = v.label;
  let extra$1 = v.value;
  return Object.fromEntries(Spice.filterOptional([
    [
      "label",
      Spice.optionToJson(Spice.stringToJson, extra)
    ],
    [
      "value",
      Spice.optionToJson(Spice.intToJson, extra$1)
    ]
  ]));
}

function tOp_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let label = Stdlib_Option.getOr(Stdlib_Option.map(v["label"], extra => Spice.optionFromJson(Spice.stringFromJson, extra)), {
    TAG: "Ok",
    _0: undefined
  });
  if (label.TAG === "Ok") {
    let value = Stdlib_Option.getOr(Stdlib_Option.map(v["value"], extra => Spice.optionFromJson(Spice.intFromJson, extra)), {
      TAG: "Ok",
      _0: undefined
    });
    if (value.TAG === "Ok") {
      return {
        TAG: "Ok",
        _0: {
          label: label._0,
          value: value._0
        }
      };
    }
    let e = value._0;
    return Spice.error("value", e.message, e.value);
  }
  let e$1 = label._0;
  return Spice.error("label", e$1.message, e$1.value);
}

function t2_encode(v) {
  let extra = v.o;
  let extra$1 = v.n;
  let extra$2 = v.on;
  let extra$3 = v.n2;
  return Object.fromEntries(Spice.filterOptional([
    [
      "o",
      Spice.optionToJson(Spice.stringToJson, extra)
    ],
    [
      "n",
      Spice.nullToJson(Spice.stringToJson, extra$1)
    ],
    [
      "on",
      Spice.optionalNullToJson(Spice.stringToJson, extra$2)
    ],
    [
      "n2",
      Spice.nullToJson(Spice.stringToJson, extra$3)
    ]
  ]));
}

function t2_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let o = Stdlib_Option.getOr(Stdlib_Option.map(v["o"], extra => Spice.optionFromJson(Spice.stringFromJson, extra)), {
    TAG: "Ok",
    _0: undefined
  });
  if (o.TAG === "Ok") {
    let n = Stdlib_Option.getOr(Stdlib_Option.map(v["n"], extra => Spice.nullFromJson(Spice.stringFromJson, extra)), Spice.error(undefined, "n" + " missing", v));
    if (n.TAG === "Ok") {
      let on = Stdlib_Option.getOr(Stdlib_Option.map(v["on"], extra => Spice.optionalNullFromJson(Spice.stringFromJson, extra)), {
        TAG: "Ok",
        _0: undefined
      });
      if (on.TAG === "Ok") {
        let n2 = Stdlib_Option.getOr(Stdlib_Option.map(v["n2"], extra => Spice.nullFromJson(Spice.stringFromJson, extra)), Spice.error(undefined, "n2" + " missing", v));
        if (n2.TAG === "Ok") {
          return {
            TAG: "Ok",
            _0: {
              o: o._0,
              n: n._0,
              on: on._0,
              n2: n2._0
            }
          };
        }
        let e = n2._0;
        return Spice.error("n2", e.message, e.value);
      }
      let e$1 = on._0;
      return Spice.error("on", e$1.message, e$1.value);
    }
    let e$2 = n._0;
    return Spice.error("n", e$2.message, e$2.value);
  }
  let e$3 = o._0;
  return Spice.error("o", e$3.message, e$3.value);
}

function t3_encode(v) {
  let extra = v.value2;
  return Object.fromEntries(Spice.filterOptional([
    [
      "value",
      Spice.intToJson(v.value)
    ],
    [
      "value2",
      Spice.optionToJson(Spice.intToJson, extra)
    ]
  ]));
}

function t3_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let value = Stdlib_Option.getOr(Stdlib_Option.map(v["value"], Spice.intFromJson), {
    TAG: "Ok",
    _0: 0
  });
  if (value.TAG === "Ok") {
    let value2 = Stdlib_Option.getOr(Stdlib_Option.map(v["value2"], extra => Spice.optionFromJson(Spice.intFromJson, extra)), {
      TAG: "Ok",
      _0: 1
    });
    if (value2.TAG === "Ok") {
      return {
        TAG: "Ok",
        _0: {
          value: value._0,
          value2: value2._0
        }
      };
    }
    let e = value2._0;
    return Spice.error("value2", e.message, e.value);
  }
  let e$1 = value._0;
  return Spice.error("value", e$1.message, e$1.value);
}

function t4_encode(v) {
  let extra = v.b;
  let extra$1 = v.c;
  return Object.fromEntries(Spice.filterOptional([
    [
      "a",
      Spice.bigintToJson(v.a)
    ],
    [
      "b",
      Spice.optionToJson(Spice.bigintToJson, extra)
    ],
    [
      "c",
      Spice.optionToJson(Spice.bigintToJson, extra$1)
    ]
  ]));
}

function t4_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let a = Stdlib_Option.getOr(Stdlib_Option.map(v["a"], Spice.bigintFromJson), Spice.error(undefined, "a" + " missing", v));
  if (a.TAG === "Ok") {
    let b = Stdlib_Option.getOr(Stdlib_Option.map(v["b"], extra => Spice.optionFromJson(Spice.bigintFromJson, extra)), {
      TAG: "Ok",
      _0: undefined
    });
    if (b.TAG === "Ok") {
      let c = Stdlib_Option.getOr(Stdlib_Option.map(v["c"], extra => Spice.optionFromJson(Spice.bigintFromJson, extra)), {
        TAG: "Ok",
        _0: undefined
      });
      if (c.TAG === "Ok") {
        return {
          TAG: "Ok",
          _0: {
            a: a._0,
            b: b._0,
            c: c._0
          }
        };
      }
      let e = c._0;
      return Spice.error("c", e.message, e.value);
    }
    let e$1 = b._0;
    return Spice.error("b", e$1.message, e$1.value);
  }
  let e$2 = a._0;
  return Spice.error("a", e$2.message, e$2.value);
}

export {
  t_encode,
  t_decode,
  t1_encode,
  t1_decode,
  tOp_encode,
  tOp_decode,
  t2_encode,
  t2_decode,
  t3_encode,
  t3_decode,
  t4_encode,
  t4_decode,
}
/* No side effect */
