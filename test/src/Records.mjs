// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Spice from "./Spice.mjs";
import * as Stdlib_Option from "@rescript/runtime/lib/es6/Stdlib_Option.js";

function t_encode(v) {
  return Object.fromEntries(Spice.filterOptional([
    [
      "spice-label",
      Spice.stringToJson(v.label)
    ],
    [
      "spice-value",
      Spice.intToJson(v.value)
    ]
  ]));
}

function t_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let label_result = Stdlib_Option.getOr(Stdlib_Option.map(v["spice-label"], Spice.stringFromJson), Spice.error(undefined, "spice-label" + " missing", v));
  let value_result = Stdlib_Option.getOr(Stdlib_Option.map(v["spice-value"], Spice.intFromJson), Spice.error(undefined, "spice-value" + " missing", v));
  if (label_result.TAG === "Ok") {
    if (value_result.TAG === "Ok") {
      return {
        TAG: "Ok",
        _0: {
          label: label_result._0,
          value: value_result._0
        }
      };
    }
    let e = value_result._0;
    return Spice.error("spice-value", e.message, e.value);
  }
  let e$1 = label_result._0;
  return Spice.error("spice-label", e$1.message, e$1.value);
}

function t1_encode(v) {
  return Object.fromEntries(Spice.filterOptional([
    [
      "label",
      Spice.stringToJson(v.label)
    ],
    [
      "value",
      Spice.intToJson(v.value)
    ]
  ]));
}

function t1_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let label_result = Stdlib_Option.getOr(Stdlib_Option.map(v["label"], Spice.stringFromJson), Spice.error(undefined, "label" + " missing", v));
  let value_result = Stdlib_Option.getOr(Stdlib_Option.map(v["value"], Spice.intFromJson), Spice.error(undefined, "value" + " missing", v));
  if (label_result.TAG === "Ok") {
    if (value_result.TAG === "Ok") {
      return {
        TAG: "Ok",
        _0: {
          label: label_result._0,
          value: value_result._0
        }
      };
    }
    let e = value_result._0;
    return Spice.error("value", e.message, e.value);
  }
  let e$1 = label_result._0;
  return Spice.error("label", e$1.message, e$1.value);
}

function tOp_encode(v) {
  let extra = v.label;
  let extra$1 = v.value;
  return Object.fromEntries(Spice.filterOptional([
    [
      "label",
      Spice.optionToJson(Spice.stringToJson, extra)
    ],
    [
      "value",
      Spice.optionToJson(Spice.intToJson, extra$1)
    ]
  ]));
}

function tOp_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let label_result = Stdlib_Option.getOr(Stdlib_Option.map(v["label"], extra => Spice.optionFromJson(Spice.stringFromJson, extra)), {
    TAG: "Ok",
    _0: undefined
  });
  let value_result = Stdlib_Option.getOr(Stdlib_Option.map(v["value"], extra => Spice.optionFromJson(Spice.intFromJson, extra)), {
    TAG: "Ok",
    _0: undefined
  });
  if (label_result.TAG === "Ok") {
    if (value_result.TAG === "Ok") {
      return {
        TAG: "Ok",
        _0: {
          label: label_result._0,
          value: value_result._0
        }
      };
    }
    let e = value_result._0;
    return Spice.error("value", e.message, e.value);
  }
  let e$1 = label_result._0;
  return Spice.error("label", e$1.message, e$1.value);
}

function t2_encode(v) {
  let extra = v.o;
  let extra$1 = v.n;
  let extra$2 = v.on;
  let extra$3 = v.n2;
  return Object.fromEntries(Spice.filterOptional([
    [
      "o",
      Spice.optionToJson(Spice.stringToJson, extra)
    ],
    [
      "n",
      Spice.nullToJson(Spice.stringToJson, extra$1)
    ],
    [
      "on",
      Spice.optionToJson(extra => Spice.nullToJson(Spice.stringToJson, extra), extra$2)
    ],
    [
      "n2",
      Spice.nullToJson(Spice.stringToJson, extra$3)
    ]
  ]));
}

function t2_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let o_result = Stdlib_Option.getOr(Stdlib_Option.map(v["o"], extra => Spice.optionFromJson(Spice.stringFromJson, extra)), {
    TAG: "Ok",
    _0: undefined
  });
  let n_result = Stdlib_Option.getOr(Stdlib_Option.map(v["n"], extra => Spice.nullFromJson(Spice.stringFromJson, extra)), Spice.error(undefined, "n" + " missing", v));
  let on_result = Stdlib_Option.getOr(Stdlib_Option.map(v["on"], extra => Spice.optionFromJson(extra => Spice.nullFromJson(Spice.stringFromJson, extra), extra)), {
    TAG: "Ok",
    _0: undefined
  });
  let n2_result = Stdlib_Option.getOr(Stdlib_Option.map(v["n2"], extra => Spice.nullFromJson(Spice.stringFromJson, extra)), Spice.error(undefined, "n2" + " missing", v));
  if (o_result.TAG === "Ok") {
    if (n_result.TAG === "Ok") {
      if (on_result.TAG === "Ok") {
        if (n2_result.TAG === "Ok") {
          return {
            TAG: "Ok",
            _0: {
              o: o_result._0,
              n: n_result._0,
              on: on_result._0,
              n2: n2_result._0
            }
          };
        }
        let e = n2_result._0;
        return Spice.error("n2", e.message, e.value);
      }
      let e$1 = on_result._0;
      return Spice.error("on", e$1.message, e$1.value);
    }
    let e$2 = n_result._0;
    return Spice.error("n", e$2.message, e$2.value);
  }
  let e$3 = o_result._0;
  return Spice.error("o", e$3.message, e$3.value);
}

function t3_encode(v) {
  let extra = v.value2;
  return Object.fromEntries(Spice.filterOptional([
    [
      "value",
      Spice.intToJson(v.value)
    ],
    [
      "value2",
      Spice.optionToJson(Spice.intToJson, extra)
    ]
  ]));
}

function t3_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let value_result = Stdlib_Option.getOr(Stdlib_Option.map(v["value"], Spice.intFromJson), {
    TAG: "Ok",
    _0: 0
  });
  let value2_result = Stdlib_Option.getOr(Stdlib_Option.map(v["value2"], extra => Spice.optionFromJson(Spice.intFromJson, extra)), {
    TAG: "Ok",
    _0: 1
  });
  if (value_result.TAG === "Ok") {
    if (value2_result.TAG === "Ok") {
      return {
        TAG: "Ok",
        _0: {
          value: value_result._0,
          value2: value2_result._0
        }
      };
    }
    let e = value2_result._0;
    return Spice.error("value2", e.message, e.value);
  }
  let e$1 = value_result._0;
  return Spice.error("value", e$1.message, e$1.value);
}

function t4_encode(v) {
  let extra = v.b;
  let extra$1 = v.c;
  return Object.fromEntries(Spice.filterOptional([
    [
      "a",
      Spice.bigintToJson(v.a)
    ],
    [
      "b",
      Spice.optionToJson(Spice.bigintToJson, extra)
    ],
    [
      "c",
      Spice.optionToJson(Spice.bigintToJson, extra$1)
    ]
  ]));
}

function t4_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let a_result = Stdlib_Option.getOr(Stdlib_Option.map(v["a"], Spice.bigintFromJson), Spice.error(undefined, "a" + " missing", v));
  let b_result = Stdlib_Option.getOr(Stdlib_Option.map(v["b"], extra => Spice.optionFromJson(Spice.bigintFromJson, extra)), {
    TAG: "Ok",
    _0: undefined
  });
  let c_result = Stdlib_Option.getOr(Stdlib_Option.map(v["c"], extra => Spice.optionFromJson(Spice.bigintFromJson, extra)), {
    TAG: "Ok",
    _0: undefined
  });
  if (a_result.TAG === "Ok") {
    if (b_result.TAG === "Ok") {
      if (c_result.TAG === "Ok") {
        return {
          TAG: "Ok",
          _0: {
            a: a_result._0,
            b: b_result._0,
            c: c_result._0
          }
        };
      }
      let e = c_result._0;
      return Spice.error("c", e.message, e.value);
    }
    let e$1 = b_result._0;
    return Spice.error("b", e$1.message, e$1.value);
  }
  let e$2 = a_result._0;
  return Spice.error("a", e$2.message, e$2.value);
}

function t5_encode(encoder_data) {
  return v => (Object.fromEntries(Spice.filterOptional([[
      "a",
      Spice.arrayToJson(encoder_data, v.a)
    ]])));
}

function t5_decode(decoder_data) {
  return v => {
    if (typeof v !== "object" || v === null || Array.isArray(v)) {
      return Spice.error(undefined, "Not an object", v);
    }
    let a_result = Stdlib_Option.getOr(Stdlib_Option.map(v["a"], extra => Spice.arrayFromJson(decoder_data, extra)), Spice.error(undefined, "a" + " missing", v));
    if (a_result.TAG === "Ok") {
      return {
        TAG: "Ok",
        _0: {
          a: a_result._0
        }
      };
    }
    let e = a_result._0;
    return Spice.error("a", e.message, e.value);
  };
}

let t5_string_encode = t5_encode(Spice.stringToJson);

let t5_string_decode = t5_decode(Spice.stringFromJson);

function t6_encode(encoder_key, encoder_value) {
  return v => (Object.fromEntries(Spice.filterOptional([
    [
      "key",
      encoder_key(v.key)
    ],
    [
      "value",
      encoder_value(v.value)
    ]
  ])));
}

function t6_decode(decoder_key, decoder_value) {
  return v => {
    if (typeof v !== "object" || v === null || Array.isArray(v)) {
      return Spice.error(undefined, "Not an object", v);
    }
    let key_result = Stdlib_Option.getOr(Stdlib_Option.map(v["key"], decoder_key), Spice.error(undefined, "key" + " missing", v));
    let value_result = Stdlib_Option.getOr(Stdlib_Option.map(v["value"], decoder_value), Spice.error(undefined, "value" + " missing", v));
    if (key_result.TAG === "Ok") {
      if (value_result.TAG === "Ok") {
        return {
          TAG: "Ok",
          _0: {
            key: key_result._0,
            value: value_result._0
          }
        };
      }
      let e = value_result._0;
      return Spice.error("value", e.message, e.value);
    }
    let e$1 = key_result._0;
    return Spice.error("key", e$1.message, e$1.value);
  };
}

let t6_string_int_encode = t6_encode(Spice.stringToJson, Spice.intToJson);

let t6_string_int_decode = t6_decode(Spice.stringFromJson, Spice.intFromJson);

export {
  t_encode,
  t_decode,
  t1_encode,
  t1_decode,
  tOp_encode,
  tOp_decode,
  t2_encode,
  t2_decode,
  t3_encode,
  t3_decode,
  t4_encode,
  t4_decode,
  t5_encode,
  t5_decode,
  t5_string_encode,
  t5_string_decode,
  t6_encode,
  t6_decode,
  t6_string_int_encode,
  t6_string_int_decode,
}
/* t5_string_encode Not a pure module */
