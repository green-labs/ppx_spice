// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Spice from "./Spice.mjs";
import * as Js_json from "rescript/lib/es6/Js_json.js";
import * as Js_array from "rescript/lib/es6/Js_array.js";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";

function t_encode(v) {
  if (v === "two") {
    return "둘";
  } else {
    return "하나";
  }
}

function t_decode(v) {
  let str_or_num = Js_json.classify(v);
  if (typeof str_or_num !== "object") {
    return Spice.error(undefined, "Not a JSONString", v);
  }
  switch (str_or_num.TAG) {
    case "JSONString" :
      let str_or_num$1 = str_or_num._0;
      if ("하나" === str_or_num$1) {
        return {
          TAG: "Ok",
          _0: "one"
        };
      } else if ("둘" === str_or_num$1) {
        return {
          TAG: "Ok",
          _0: "two"
        };
      } else {
        return Spice.error(undefined, "Not matched", v);
      }
    case "JSONNumber" :
      return Spice.error(undefined, "Not matched", v);
    default:
      return Spice.error(undefined, "Not a JSONString", v);
  }
}

function t1_encode(v) {
  if (v === "two") {
    return ["two"];
  } else {
    return ["one"];
  }
}

function t1_decode(v) {
  let json_arr = Js_json.classify(v);
  if (typeof json_arr !== "object") {
    return Spice.error(undefined, "Not a polyvariant", v);
  }
  if (json_arr.TAG !== "JSONArray") {
    return Spice.error(undefined, "Not a polyvariant", v);
  }
  let json_arr$1 = json_arr._0;
  if (json_arr$1.length === 0) {
    return Spice.error(undefined, "Expected polyvariant, found empty array", v);
  }
  let tagged = Js_array.map(Js_json.classify, json_arr$1);
  let match = Belt_Array.getExn(tagged, 0);
  if (typeof match === "object" && match.TAG === "JSONString") {
    switch (match._0) {
      case "one" :
        if (tagged.length !== 1) {
          return Spice.error(undefined, "Invalid number of arguments to polyvariant constructor", v);
        } else {
          return {
            TAG: "Ok",
            _0: "one"
          };
        }
      case "two" :
        if (tagged.length !== 1) {
          return Spice.error(undefined, "Invalid number of arguments to polyvariant constructor", v);
        } else {
          return {
            TAG: "Ok",
            _0: "two"
          };
        }
    }
  }
  return Spice.error(undefined, "Invalid polymorphic constructor", Belt_Array.getExn(json_arr$1, 0));
}

function t2_encode(v) {
  if (v === "two") {
    return 2.0;
  } else {
    return 1.0;
  }
}

function t2_decode(v) {
  let str_or_num = Js_json.classify(v);
  if (typeof str_or_num !== "object") {
    return Spice.error(undefined, "Not a JSONString", v);
  }
  switch (str_or_num.TAG) {
    case "JSONString" :
      return Spice.error(undefined, "Not matched", v);
    case "JSONNumber" :
      let str_or_num$1 = str_or_num._0;
      if (1.0 === str_or_num$1) {
        return {
          TAG: "Ok",
          _0: "one"
        };
      } else if (2.0 === str_or_num$1) {
        return {
          TAG: "Ok",
          _0: "two"
        };
      } else {
        return Spice.error(undefined, "Not matched", v);
      }
    default:
      return Spice.error(undefined, "Not a JSONString", v);
  }
}

export {
  t_encode,
  t_decode,
  t1_encode,
  t1_decode,
  t2_encode,
  t2_decode,
}
/* No side effect */
