// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "rescript/lib/es6/Js_dict.js";
import * as Js_math from "rescript/lib/es6/Js_math.js";
import * as Js_array from "rescript/lib/es6/Js_array.js";
import * as Belt_List from "rescript/lib/es6/Belt_List.js";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Belt_Result from "rescript/lib/es6/Belt_Result.js";
import * as Spice_Codecs from "./Spice_Codecs.mjs";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";

function error(path, message, value) {
  let path$1 = path !== undefined ? path : "";
  return {
    TAG: "Error",
    _0: {
      path: path$1,
      message: message,
      value: value
    }
  };
}

function stringToJson(s) {
  return s;
}

function stringFromJson(j) {
  if (!Array.isArray(j) && (j === null || typeof j !== "object") && typeof j !== "number" && typeof j !== "string" && typeof j !== "boolean" || typeof j !== "string") {
    return {
      TAG: "Error",
      _0: {
        path: "",
        message: "Not a string",
        value: j
      }
    };
  } else {
    return {
      TAG: "Ok",
      _0: j
    };
  }
}

function intToJson(i) {
  return i;
}

function intFromJson(j) {
  if (!Array.isArray(j) && (j === null || typeof j !== "object") && typeof j !== "number" && typeof j !== "string" && typeof j !== "boolean" || typeof j !== "number") {
    return {
      TAG: "Error",
      _0: {
        path: "",
        message: "Not a number",
        value: j
      }
    };
  } else if (Js_math.floor(j) === j) {
    return {
      TAG: "Ok",
      _0: Js_math.floor(j)
    };
  } else {
    return {
      TAG: "Error",
      _0: {
        path: "",
        message: "Not an integer",
        value: j
      }
    };
  }
}

function int64ToJson(i) {
  return Number(i);
}

function int64FromJson(j) {
  if (!Array.isArray(j) && (j === null || typeof j !== "object") && typeof j !== "number" && typeof j !== "string" && typeof j !== "boolean" || typeof j !== "number") {
    return error(undefined, "Not a number", j);
  } else {
    return {
      TAG: "Ok",
      _0: BigInt(j)
    };
  }
}

function int64ToJsonUnsafe(i) {
  return Number(i);
}

function int64FromJsonUnsafe(j) {
  if (!Array.isArray(j) && (j === null || typeof j !== "object") && typeof j !== "number" && typeof j !== "string" && typeof j !== "boolean" || typeof j !== "number") {
    return error(undefined, "Not a number", j);
  } else {
    return {
      TAG: "Ok",
      _0: BigInt(j)
    };
  }
}

function floatToJson(v) {
  return v;
}

function floatFromJson(j) {
  if (!Array.isArray(j) && (j === null || typeof j !== "object") && typeof j !== "number" && typeof j !== "string" && typeof j !== "boolean" || typeof j !== "number") {
    return {
      TAG: "Error",
      _0: {
        path: "",
        message: "Not a number",
        value: j
      }
    };
  } else {
    return {
      TAG: "Ok",
      _0: j
    };
  }
}

function boolToJson(v) {
  if (v) {
    return true;
  } else {
    return false;
  }
}

function boolFromJson(j) {
  if (!Array.isArray(j) && (j === null || typeof j !== "object") && typeof j !== "number" && typeof j !== "string" && typeof j !== "boolean" || typeof j !== "boolean") {
    return {
      TAG: "Error",
      _0: {
        path: "",
        message: "Not a boolean",
        value: j
      }
    };
  } else if (j) {
    return {
      TAG: "Ok",
      _0: true
    };
  } else {
    return {
      TAG: "Ok",
      _0: false
    };
  }
}

function unitToJson() {
  return 0.0;
}

function unitFromJson(param) {
  return {
    TAG: "Ok",
    _0: undefined
  };
}

function arrayToJson(encoder, arr) {
  return Js_array.map(encoder, arr);
}

function arrayFromJson(decoder, json) {
  if (!Array.isArray(json) && (json === null || typeof json !== "object") && typeof json !== "number" && typeof json !== "string" && typeof json !== "boolean" || !Array.isArray(json)) {
    return {
      TAG: "Error",
      _0: {
        path: "",
        message: "Not an array",
        value: json
      }
    };
  } else {
    return Js_array.reducei((acc, jsonI, i) => {
      let match = decoder(jsonI);
      if (acc.TAG !== "Ok") {
        return acc;
      }
      if (match.TAG === "Ok") {
        return {
          TAG: "Ok",
          _0: Js_array.concat([match._0], acc._0)
        };
      }
      let error = match._0;
      return {
        TAG: "Error",
        _0: {
          path: "[" + (i.toString() + ("]" + error.path)),
          message: error.message,
          value: error.value
        }
      };
    }, {
      TAG: "Ok",
      _0: []
    }, json);
  }
}

function listToJson(encoder, list) {
  let arr = Belt_List.toArray(list);
  return Js_array.map(encoder, arr);
}

function listFromJson(decoder, json) {
  return Belt_Result.map(arrayFromJson(decoder, json), Belt_List.fromArray);
}

function filterOptional(arr) {
  return Belt_Array.keepMap(arr, param => {
    let v = param[1];
    if (v !== undefined) {
      return [
        param[0],
        Primitive_option.valFromOption(v)
      ];
    }
    
  });
}

function optionToJson(encoder, opt) {
  if (opt !== undefined) {
    return encoder(Primitive_option.valFromOption(opt));
  }
  
}

function optionFromJson(decoder, json) {
  if (!Array.isArray(json) && (json === null || typeof json !== "object") && typeof json !== "number" && typeof json !== "string" && typeof json !== "boolean") {
    return {
      TAG: "Ok",
      _0: undefined
    };
  } else {
    return Belt_Result.map(decoder(json), v => Primitive_option.some(v));
  }
}

function nullToJson(encoder, opt) {
  if (opt === null) {
    return null;
  } else {
    return encoder(opt);
  }
}

function nullFromJson(decoder, json) {
  if (!Array.isArray(json) && (json === null || typeof json !== "object") && typeof json !== "number" && typeof json !== "string" && typeof json !== "boolean") {
    return {
      TAG: "Ok",
      _0: null
    };
  } else {
    return Belt_Result.map(decoder(json), v => (v));
  }
}

function resultToJson(okEncoder, errorEncoder, result) {
  let tmp;
  tmp = result.TAG === "Ok" ? [
      "Ok",
      okEncoder(result._0)
    ] : [
      "Error",
      errorEncoder(result._0)
    ];
  return tmp;
}

function resultFromJson(okDecoder, errorDecoder, json) {
  if (!Array.isArray(json) && (json === null || typeof json !== "object") && typeof json !== "number" && typeof json !== "string" && typeof json !== "boolean") {
    return error(undefined, "Not an array", json);
  }
  if (!Array.isArray(json)) {
    return error(undefined, "Not an array", json);
  }
  if (json.length !== 2) {
    return error(undefined, "Expected exactly 2 values in array", json);
  }
  let variantConstructorId = json[0];
  let payload = json[1];
  if (!Array.isArray(variantConstructorId) && (variantConstructorId === null || typeof variantConstructorId !== "object") && typeof variantConstructorId !== "number" && typeof variantConstructorId !== "string" && typeof variantConstructorId !== "boolean") {
    return error(undefined, "Not a string", variantConstructorId);
  }
  if (typeof variantConstructorId !== "string") {
    return error(undefined, "Not a string", variantConstructorId);
  }
  switch (variantConstructorId) {
    case "Error" :
      let v = errorDecoder(payload);
      if (v.TAG === "Ok") {
        return {
          TAG: "Ok",
          _0: {
            TAG: "Error",
            _0: v._0
          }
        };
      } else {
        return {
          TAG: "Error",
          _0: v._0
        };
      }
    case "Ok" :
      return Belt_Result.map(okDecoder(payload), v => ({
        TAG: "Ok",
        _0: v
      }));
    default:
      return error(undefined, "Expected either \"Ok\" or \"Error\"", variantConstructorId);
  }
}

function dictToJson(encoder, dict) {
  return Js_dict.map(a => encoder(a), dict);
}

function dictFromJson(decoder, json) {
  if (!Array.isArray(json) && (json === null || typeof json !== "object") && typeof json !== "number" && typeof json !== "string" && typeof json !== "boolean" || !(typeof json === "object" && !Array.isArray(json))) {
    return {
      TAG: "Error",
      _0: {
        path: "",
        message: "Not a dict",
        value: json
      }
    };
  } else {
    return Belt_Array.reduce(Js_dict.entries(json), {
      TAG: "Ok",
      _0: {}
    }, (acc, param) => {
      let key = param[0];
      let match = decoder(param[1]);
      if (acc.TAG !== "Ok") {
        return acc;
      }
      let prev = acc._0;
      if (match.TAG === "Ok") {
        prev[key] = match._0;
        return {
          TAG: "Ok",
          _0: prev
        };
      }
      let error = match._0;
      return {
        TAG: "Error",
        _0: {
          path: "." + (key + error.path),
          message: error.message,
          value: error.value
        }
      };
    });
  }
}

let string = [
  stringToJson,
  stringFromJson
];

let int = [
  intToJson,
  intFromJson
];

let int64Unsafe = [
  int64ToJsonUnsafe,
  int64FromJsonUnsafe
];

let float = [
  floatToJson,
  floatFromJson
];

let bool = [
  boolToJson,
  boolFromJson
];

let array = [
  arrayToJson,
  arrayFromJson
];

let list = [
  listToJson,
  listFromJson
];

let option = [
  optionToJson,
  optionFromJson
];

let unit = [
  unitToJson,
  unitFromJson
];

let Codecs = {
  falseableEncode: Spice_Codecs.falseableEncode,
  falseableDecode: Spice_Codecs.falseableDecode,
  falseable: Spice_Codecs.falseable,
  magicDecode: Spice_Codecs.magicDecode,
  magic: Spice_Codecs.magic,
  string: string,
  int: int,
  int64Unsafe: int64Unsafe,
  float: float,
  bool: bool,
  array: array,
  list: list,
  option: option,
  unit: unit
};

export {
  error,
  stringToJson,
  stringFromJson,
  intToJson,
  intFromJson,
  int64ToJson,
  int64FromJson,
  int64ToJsonUnsafe,
  int64FromJsonUnsafe,
  floatToJson,
  floatFromJson,
  boolToJson,
  boolFromJson,
  unitToJson,
  unitFromJson,
  arrayToJson,
  arrayFromJson,
  listToJson,
  listFromJson,
  filterOptional,
  optionToJson,
  optionFromJson,
  nullToJson,
  nullFromJson,
  resultToJson,
  resultFromJson,
  dictToJson,
  dictFromJson,
  Codecs,
}
/* No side effect */
