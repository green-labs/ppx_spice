// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Spice from "./Spice.mjs";
import * as Stdlib_Option from "@rescript/runtime/lib/es6/Stdlib_Option.js";

function t_encode(v) {
  return Object.fromEntries(Spice.filterOptional([
    [
      "name",
      Spice.stringToJson(v.name)
    ],
    [
      "value",
      Spice.intToJson(v.value)
    ]
  ]));
}

function t_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let name = Stdlib_Option.getOr(Stdlib_Option.map(v["name"], Spice.stringFromJson), Spice.error(undefined, "name" + " missing", v));
  if (name.TAG === "Ok") {
    let value = Stdlib_Option.getOr(Stdlib_Option.map(v["value"], Spice.intFromJson), Spice.error(undefined, "value" + " missing", v));
    if (value.TAG === "Ok") {
      return {
        TAG: "Ok",
        _0: {
          name: name._0,
          value: value._0
        }
      };
    }
    let e = value._0;
    return Spice.error("value", e.message, e.value);
  }
  let e$1 = name._0;
  return Spice.error("name", e$1.message, e$1.value);
}

let Inner = {
  t_encode: t_encode,
  t_decode: t_decode
};

function t_encode$1(v) {
  return Object.fromEntries(Spice.filterOptional([
    [
      "label",
      Spice.stringToJson(v.label)
    ],
    [
      "count",
      Spice.floatToJson(v.count)
    ]
  ]));
}

function t_decode$1(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let label = Stdlib_Option.getOr(Stdlib_Option.map(v["label"], Spice.stringFromJson), Spice.error(undefined, "label" + " missing", v));
  if (label.TAG === "Ok") {
    let count = Stdlib_Option.getOr(Stdlib_Option.map(v["count"], Spice.floatFromJson), Spice.error(undefined, "count" + " missing", v));
    if (count.TAG === "Ok") {
      return {
        TAG: "Ok",
        _0: {
          label: label._0,
          count: count._0
        }
      };
    }
    let e = count._0;
    return Spice.error("count", e.message, e.value);
  }
  let e$1 = label._0;
  return Spice.error("label", e$1.message, e$1.value);
}

let Nested = {
  t_encode: t_encode$1,
  t_decode: t_decode$1
};

function wrapper_encode(v) {
  return Object.fromEntries(Spice.filterOptional([
    [
      "inner",
      t_encode(v.inner)
    ],
    [
      "nested",
      t_encode$1(v.nested)
    ]
  ]));
}

function wrapper_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let inner = Stdlib_Option.getOr(Stdlib_Option.map(v["inner"], t_decode), Spice.error(undefined, "inner" + " missing", v));
  if (inner.TAG === "Ok") {
    let nested = Stdlib_Option.getOr(Stdlib_Option.map(v["nested"], t_decode$1), Spice.error(undefined, "nested" + " missing", v));
    if (nested.TAG === "Ok") {
      return {
        TAG: "Ok",
        _0: {
          inner: inner._0,
          nested: nested._0
        }
      };
    }
    let e = nested._0;
    return Spice.error("nested", e.message, e.value);
  }
  let e$1 = inner._0;
  return Spice.error("inner", e$1.message, e$1.value);
}

let Outer = {
  Nested: Nested,
  wrapper_encode: wrapper_encode,
  wrapper_decode: wrapper_decode
};

function combined_encode(v) {
  return Object.fromEntries(Spice.filterOptional([
    [
      "inner",
      t_encode(v.inner)
    ],
    [
      "nested",
      t_encode$1(v.nested)
    ]
  ]));
}

function combined_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let inner = Stdlib_Option.getOr(Stdlib_Option.map(v["inner"], t_decode), Spice.error(undefined, "inner" + " missing", v));
  if (inner.TAG === "Ok") {
    let nested = Stdlib_Option.getOr(Stdlib_Option.map(v["nested"], t_decode$1), Spice.error(undefined, "nested" + " missing", v));
    if (nested.TAG === "Ok") {
      return {
        TAG: "Ok",
        _0: {
          inner: inner._0,
          nested: nested._0
        }
      };
    }
    let e = nested._0;
    return Spice.error("nested", e.message, e.value);
  }
  let e$1 = inner._0;
  return Spice.error("inner", e$1.message, e$1.value);
}

export {
  Inner,
  Outer,
  combined_encode,
  combined_decode,
}
/* No side effect */
