// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Spice from "./Spice.mjs";
import * as Stdlib_Result from "@rescript/runtime/lib/es6/Stdlib_Result.js";

function t_encode(v) {
  if (v === "One") {
    return 1;
  } else {
    return "둘";
  }
}

function t_decode(v) {
  switch (typeof v) {
    case "string" :
      if ("둘" === v) {
        return {
          TAG: "Ok",
          _0: "Two"
        };
      } else {
        return Spice.error(undefined, "Not matched", v);
      }
    case "number" :
      if (1 === v) {
        return {
          TAG: "Ok",
          _0: "One"
        };
      } else {
        return Spice.error(undefined, "Not matched", v);
      }
    default:
      return Spice.error(undefined, "Not a JSONString", v);
  }
}

function t1_encode(v) {
  if (v === "One1") {
    return ["One1"];
  } else {
    return ["Two1"];
  }
}

function t1_decode(v) {
  if (!Array.isArray(v)) {
    return Spice.error(undefined, "Not a variant", v);
  }
  if (v.length === 0) {
    return Spice.error(undefined, "Expected variant, found empty array", v);
  }
  let match = v[0];
  if (typeof match === "string") {
    switch (match) {
      case "One1" :
        if (v.length !== 1) {
          return Spice.error(undefined, "Invalid number of arguments to variant constructor", v);
        } else {
          return {
            TAG: "Ok",
            _0: "One1"
          };
        }
      case "Two1" :
        if (v.length !== 1) {
          return Spice.error(undefined, "Invalid number of arguments to variant constructor", v);
        } else {
          return {
            TAG: "Ok",
            _0: "Two1"
          };
        }
    }
  }
  return Spice.error(undefined, "Invalid variant constructor", v[0]);
}

let t2_encode = Spice.intToJson;

function t2_decode(v) {
  return Stdlib_Result.map(Spice.intFromJson(v), v => v);
}

let t3_encode = Spice.intToJson;

function t3_decode(v) {
  return Stdlib_Result.map(Spice.intFromJson(v), v => v);
}

function t4_encode(v) {
  if (v === "One") {
    return 1.0;
  } else {
    return 2.0;
  }
}

function t4_decode(v) {
  switch (typeof v) {
    case "string" :
      return Spice.error(undefined, "Not matched", v);
    case "number" :
      if (1.0 === v) {
        return {
          TAG: "Ok",
          _0: "One"
        };
      } else if (2.0 === v) {
        return {
          TAG: "Ok",
          _0: "Two"
        };
      } else {
        return Spice.error(undefined, "Not matched", v);
      }
    default:
      return Spice.error(undefined, "Not a JSONString", v);
  }
}

function withArgs_decode(v) {
  if (!Array.isArray(v)) {
    return Spice.error(undefined, "Not a variant", v);
  }
  if (v.length === 0) {
    return Spice.error(undefined, "Expected variant, found empty array", v);
  }
  let match = v[0];
  if (match === "WithArgs") {
    if (v.length !== 3) {
      return Spice.error(undefined, "Invalid number of arguments to variant constructor", v);
    }
    let match$1 = Spice.intFromJson(v[1]);
    let match$2 = Spice.stringFromJson(v[2]);
    if (match$1.TAG === "Ok") {
      if (match$2.TAG === "Ok") {
        return {
          TAG: "Ok",
          _0: {
            TAG: "WithArgs",
            _0: match$1._0,
            _1: match$2._0
          }
        };
      }
      let e = match$2._0;
      return {
        TAG: "Error",
        _0: {
          path: "[2]" + e.path,
          message: e.message,
          value: e.value
        }
      };
    }
    let e$1 = match$1._0;
    return {
      TAG: "Error",
      _0: {
        path: "[1]" + e$1.path,
        message: e$1.message,
        value: e$1.value
      }
    };
  }
  return Spice.error(undefined, "Invalid variant constructor", v[0]);
}

export {
  t_encode,
  t_decode,
  t1_encode,
  t1_decode,
  t2_encode,
  t2_decode,
  t3_encode,
  t3_decode,
  t4_encode,
  t4_decode,
  withArgs_decode,
}
/* No side effect */
