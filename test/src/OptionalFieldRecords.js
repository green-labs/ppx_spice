// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Spice = require("./Spice.js");
var Js_dict = require("rescript/lib/js/js_dict.js");
var Js_json = require("rescript/lib/js/js_json.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");

function t0_encode(v) {
  return Js_dict.fromArray(Spice.filterOptional([
                  [
                    "a",
                    false,
                    Spice.intToJson(v.a)
                  ],
                  [
                    "b",
                    true,
                    Spice.optionToJson(Spice.intToJson, v.b)
                  ]
                ]));
}

function t0_decode(v) {
  var dict = Js_json.classify(v);
  if (typeof dict === "number") {
    return Spice.error(undefined, "Not an object", v);
  }
  if (dict.TAG !== /* JSONObject */2) {
    return Spice.error(undefined, "Not an object", v);
  }
  var dict$1 = dict._0;
  var a = Spice.intFromJson(Belt_Option.getWithDefault(Js_dict.get(dict$1, "a"), null));
  if (a.TAG === /* Ok */0) {
    var b = Spice.optionFromJson(Spice.intFromJson, Belt_Option.getWithDefault(Js_dict.get(dict$1, "b"), null));
    if (b.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: {
                a: a._0,
                b: b._0
              }
            };
    }
    var e = b._0;
    return {
            TAG: /* Error */1,
            _0: {
              path: ".b" + e.path,
              message: e.message,
              value: e.value
            }
          };
  }
  var e$1 = a._0;
  return {
          TAG: /* Error */1,
          _0: {
            path: ".a" + e$1.path,
            message: e$1.message,
            value: e$1.value
          }
        };
}

function t1_encode(v) {
  return Js_dict.fromArray(Spice.filterOptional([
                  [
                    "a",
                    false,
                    Spice.intToJson(v.a)
                  ],
                  [
                    "bs",
                    true,
                    Spice.optionToJson((function (param) {
                            return Spice.arrayToJson(Spice.intToJson, param);
                          }), v.bs)
                  ]
                ]));
}

function t1_decode(v) {
  var dict = Js_json.classify(v);
  if (typeof dict === "number") {
    return Spice.error(undefined, "Not an object", v);
  }
  if (dict.TAG !== /* JSONObject */2) {
    return Spice.error(undefined, "Not an object", v);
  }
  var dict$1 = dict._0;
  var a = Spice.intFromJson(Belt_Option.getWithDefault(Js_dict.get(dict$1, "a"), null));
  if (a.TAG === /* Ok */0) {
    var bs = Spice.optionFromJson((function (param) {
            return Spice.arrayFromJson(Spice.intFromJson, param);
          }), Belt_Option.getWithDefault(Js_dict.get(dict$1, "bs"), null));
    if (bs.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: {
                a: a._0,
                bs: bs._0
              }
            };
    }
    var e = bs._0;
    return {
            TAG: /* Error */1,
            _0: {
              path: ".bs" + e.path,
              message: e.message,
              value: e.value
            }
          };
  }
  var e$1 = a._0;
  return {
          TAG: /* Error */1,
          _0: {
            path: ".a" + e$1.path,
            message: e$1.message,
            value: e$1.value
          }
        };
}

function b_encode(v) {
  switch (v) {
    case /* B0 */0 :
        return "B0";
    case /* B1 */1 :
        return "B1";
    case /* B2 */2 :
        return "B2";
    
  }
}

function b_decode(v) {
  var str = Js_json.classify(v);
  if (typeof str === "number") {
    return Spice.error(undefined, "Not a JSONString", v);
  }
  if (str.TAG !== /* JSONString */0) {
    return Spice.error(undefined, "Not a JSONString", v);
  }
  var str$1 = str._0;
  if ("B0" === str$1) {
    return {
            TAG: /* Ok */0,
            _0: /* B0 */0
          };
  } else if ("B1" === str$1) {
    return {
            TAG: /* Ok */0,
            _0: /* B1 */1
          };
  } else if ("B2" === str$1) {
    return {
            TAG: /* Ok */0,
            _0: /* B2 */2
          };
  } else {
    return Spice.error(undefined, "Not matched", v);
  }
}

function t2_encode(v) {
  return Js_dict.fromArray(Spice.filterOptional([
                  [
                    "a",
                    false,
                    Spice.intToJson(v.a)
                  ],
                  [
                    "bs",
                    true,
                    Spice.optionToJson((function (param) {
                            return Spice.arrayToJson(b_encode, param);
                          }), v.bs)
                  ]
                ]));
}

function t2_decode(v) {
  var dict = Js_json.classify(v);
  if (typeof dict === "number") {
    return Spice.error(undefined, "Not an object", v);
  }
  if (dict.TAG !== /* JSONObject */2) {
    return Spice.error(undefined, "Not an object", v);
  }
  var dict$1 = dict._0;
  var a = Spice.intFromJson(Belt_Option.getWithDefault(Js_dict.get(dict$1, "a"), null));
  if (a.TAG === /* Ok */0) {
    var bs = Spice.optionFromJson((function (param) {
            return Spice.arrayFromJson(b_decode, param);
          }), Belt_Option.getWithDefault(Js_dict.get(dict$1, "bs"), null));
    if (bs.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: {
                a: a._0,
                bs: bs._0
              }
            };
    }
    var e = bs._0;
    return {
            TAG: /* Error */1,
            _0: {
              path: ".bs" + e.path,
              message: e.message,
              value: e.value
            }
          };
  }
  var e$1 = a._0;
  return {
          TAG: /* Error */1,
          _0: {
            path: ".a" + e$1.path,
            message: e$1.message,
            value: e$1.value
          }
        };
}

exports.t0_encode = t0_encode;
exports.t0_decode = t0_decode;
exports.t1_encode = t1_encode;
exports.t1_decode = t1_decode;
exports.b_encode = b_encode;
exports.b_decode = b_decode;
exports.t2_encode = t2_encode;
exports.t2_decode = t2_decode;
/* No side effect */
