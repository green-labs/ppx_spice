// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Zora from "zora";
import * as Spice from "../../../src/Spice.mjs";
import * as Js_dict from "@rescript/runtime/lib/es6/Js_dict.js";
import * as Js_json from "@rescript/runtime/lib/es6/Js_json.js";
import * as Js_array from "@rescript/runtime/lib/es6/Js_array.js";
import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";
import * as Belt_Option from "@rescript/runtime/lib/es6/Belt_Option.js";
import * as EncodeDecode from "../../../src/EncodeDecode.mjs";

function testEqual(t, name, lhs, rhs) {
  t.test(name, async t => {
    t.equal(lhs, rhs, name);
  });
}

Zora.test("encode only", t => {
  let sample = {};
  sample["name"] = "Alice";
  sample["nickname"] = "Ecila";
  let encoded = EncodeDecode.te_encode({
    name: "Alice",
    nickname: "Ecila"
  });
  testEqual(t, "encode", encoded, sample);
});

Zora.test("decode only", t => {
  let sample = {};
  sample["name"] = "Alice";
  sample["nickname"] = "Ecila";
  let decoded = EncodeDecode.td_decode(sample);
  testEqual(t, "decode", decoded, {
    TAG: "Ok",
    _0: {
      name: "Alice",
      nickname: "Ecila"
    }
  });
});

function inner_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let value_result = Belt_Option.getWithDefault(Belt_Option.map(Js_dict.get(v, "value"), Spice.intFromJson), Spice.error(undefined, "value" + " missing", v));
  if (value_result.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: {
        value: value_result._0
      }
    };
  }
  let e = value_result._0;
  return Spice.error("." + ("value" + e.path), e.message, e.value);
}

function outer_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let inner_result = Belt_Option.getWithDefault(Belt_Option.map(Js_dict.get(v, "inner"), inner_decode), Spice.error(undefined, "inner" + " missing", v));
  if (inner_result.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: {
        inner: inner_result._0
      }
    };
  }
  let e = inner_result._0;
  return Spice.error("." + ("inner" + e.path), e.message, e.value);
}

function arrayWrapper_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let arr_result = Belt_Option.getWithDefault(Belt_Option.map(Js_dict.get(v, "arr"), extra => Spice.arrayFromJson(Spice.intFromJson, extra)), Spice.error(undefined, "arr" + " missing", v));
  if (arr_result.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: {
        arr: arr_result._0
      }
    };
  }
  let e = arr_result._0;
  return Spice.error("." + ("arr" + e.path), e.message, e.value);
}

Zora.test("decode error path", t => {
  t.test("nested record path", async t => {
    let json = Js_dict.fromArray([[
        "inner",
        Js_dict.fromArray([[
            "value",
            "not an int"
          ]])
      ]]);
    let result = outer_decode(json);
    if (result.TAG === "Ok") {
      t.fail("should have failed");
      return;
    }
    t.equal(result._0.path, ".inner.value", "path should be .inner.value");
  });
  t.test("array index path", async t => {
    let json = Js_dict.fromArray([[
        "arr",
        [
          1.0,
          "bad"
        ]
      ]]);
    let result = arrayWrapper_decode(json);
    if (result.TAG === "Ok") {
      t.fail("should have failed");
      return;
    }
    t.equal(result._0.path, ".arr[1]", "path should be .arr[1]");
  });
});

function v_decode(v) {
  if (!Array.isArray(v)) {
    return Spice.error(undefined, "Not a variant", v);
  }
  if (v.length === 0) {
    return Spice.error(undefined, "Expected variant, found empty array", v);
  }
  let match = Belt_Array.getExn(v, 0);
  if (match === "A") {
    if (v.length !== 2) {
      return Spice.error(undefined, "Invalid number of arguments to variant constructor", v);
    }
    let v0 = Spice.intFromJson(Belt_Array.getExn(v, 1));
    if (v0.TAG === "Ok") {
      return {
        TAG: "Ok",
        _0: {
          TAG: "A",
          _0: v0._0
        }
      };
    }
    let e = v0._0;
    return Spice.error("[1]" + e.path, e.message, e.value);
  }
  return Spice.error(undefined, "Invalid variant constructor", Belt_Array.getExn(v, 0));
}

Zora.test("variant error path", t => {
  t.test("variant arg path", async t => {
    let json = [
      "A",
      "bad"
    ];
    let result = v_decode(json);
    if (result.TAG === "Ok") {
      t.fail("should have failed");
      return;
    }
    t.equal(result._0.path, "[1]", "path should be [1]");
  });
});

function pv_decode(v) {
  let json_arr = Js_json.classify(v);
  if (typeof json_arr !== "object") {
    return Spice.error(undefined, "Not a polyvariant", v);
  }
  if (json_arr.TAG !== "JSONArray") {
    return Spice.error(undefined, "Not a polyvariant", v);
  }
  let json_arr$1 = json_arr._0;
  if (json_arr$1.length === 0) {
    return Spice.error(undefined, "Expected polyvariant, found empty array", v);
  }
  let tagged = Js_array.map(Js_json.classify, json_arr$1);
  let match = Belt_Array.getExn(tagged, 0);
  if (typeof match === "object" && match.TAG === "JSONString") {
    switch (match._0) {
      case "A" :
        if (tagged.length !== 2) {
          return Spice.error(undefined, "Invalid number of arguments to polyvariant constructor", v);
        }
        let v0 = Spice.intFromJson(Belt_Array.getExn(json_arr$1, 1));
        if (v0.TAG === "Ok") {
          return {
            TAG: "Ok",
            _0: {
              NAME: "A",
              VAL: v0._0
            }
          };
        }
        let e = v0._0;
        return Spice.error("[1]" + e.path, e.message, e.value);
      case "B" :
        if (tagged.length !== 4) {
          return Spice.error(undefined, "Invalid number of arguments to polyvariant constructor", v);
        }
        let match$1 = Spice.intFromJson(Belt_Array.getExn(json_arr$1, 1));
        let match$2 = Spice.stringFromJson(Belt_Array.getExn(json_arr$1, 2));
        let match$3 = Spice.floatFromJson(Belt_Array.getExn(json_arr$1, 3));
        if (match$1.TAG === "Ok") {
          if (match$2.TAG === "Ok") {
            if (match$3.TAG === "Ok") {
              return {
                TAG: "Ok",
                _0: {
                  NAME: "B",
                  VAL: [
                    match$1._0,
                    match$2._0,
                    match$3._0
                  ]
                }
              };
            }
            let e$1 = match$3._0;
            return Spice.error("[3]" + e$1.path, e$1.message, e$1.value);
          }
          let e$2 = match$2._0;
          return Spice.error("[2]" + e$2.path, e$2.message, e$2.value);
        }
        let e$3 = match$1._0;
        return Spice.error("[1]" + e$3.path, e$3.message, e$3.value);
    }
  }
  return Spice.error(undefined, "Invalid polymorphic constructor", Belt_Array.getExn(json_arr$1, 0));
}

Zora.test("polyvariant error path", t => {
  t.test("polyvariant case path", async t => {
    let json = [
      "C",
      "bad"
    ];
    let result = pv_decode(json);
    if (result.TAG === "Ok") {
      t.fail("should have failed");
      return;
    }
    let e = result._0;
    t.equal(e.message, "Invalid polymorphic constructor", "message should be 'Invalid polymorphic constructor'");
    t.equal(e.path, "[0]", "path should be [0]");
  });
  t.test("polyvariant arg path", async t => {
    let json = [
      "A",
      "bad"
    ];
    let result = pv_decode(json);
    if (result.TAG === "Ok") {
      t.fail("should have failed");
      return;
    }
    t.equal(result._0.path, "[1]", "path should be [1]");
  });
  t.test("polyvariant multi-arg path", async t => {
    let json = [
      "B",
      1.0,
      "good",
      "bad"
    ];
    let result = pv_decode(json);
    if (result.TAG === "Ok") {
      t.fail("should have failed");
      return;
    }
    t.equal(result._0.path, "[3]", "path should be [3]");
  });
});

function tupleWrapper_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let t_result = Belt_Option.getWithDefault(Belt_Option.map(Js_dict.get(v, "t"), json => {
    if (!Array.isArray(json)) {
      return Spice.error(undefined, "Not a tuple", json);
    }
    if (json.length !== 4) {
      return Spice.error(undefined, "Incorrect cardinality", json);
    }
    let v0 = json[0];
    let v1 = json[1];
    let v2 = json[2];
    let v3 = json[3];
    let match = Spice.intFromJson(v0);
    let match$1 = Spice.stringFromJson(v1);
    let match$2 = Spice.intFromJson(v2);
    let match$3 = Spice.floatFromJson(v3);
    if (match.TAG === "Ok") {
      if (match$1.TAG === "Ok") {
        if (match$2.TAG === "Ok") {
          if (match$3.TAG === "Ok") {
            return {
              TAG: "Ok",
              _0: [
                match._0,
                match$1._0,
                match$2._0,
                match$3._0
              ]
            };
          }
          let e = match$3._0;
          return Spice.error("[3]" + e.path, e.message, e.value);
        }
        let e$1 = match$2._0;
        return Spice.error("[2]" + e$1.path, e$1.message, e$1.value);
      }
      let e$2 = match$1._0;
      return Spice.error("[1]" + e$2.path, e$2.message, e$2.value);
    }
    let e$3 = match._0;
    return Spice.error("[0]" + e$3.path, e$3.message, e$3.value);
  }), Spice.error(undefined, "t" + " missing", v));
  if (t_result.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: {
        t: t_result._0
      }
    };
  }
  let e = t_result._0;
  return Spice.error("." + ("t" + e.path), e.message, e.value);
}

function dictWrapper_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let d_result = Belt_Option.getWithDefault(Belt_Option.map(Js_dict.get(v, "d"), extra => Spice.dictFromJson(Spice.intFromJson, extra)), Spice.error(undefined, "d" + " missing", v));
  if (d_result.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: {
        d: d_result._0
      }
    };
  }
  let e = d_result._0;
  return Spice.error("." + ("d" + e.path), e.message, e.value);
}

Zora.test("other types error path", t => {
  t.test("tuple path", async t => {
    let json = {
      t: [
        1.0,
        "ok",
        "bad",
        4.0
      ]
    };
    let result = tupleWrapper_decode(json);
    if (result.TAG === "Ok") {
      t.fail("should have failed");
      return;
    }
    t.equal(result._0.path, ".t[2]", "path should be .t[2]");
  });
  t.test("dict path", async t => {
    let json = {
      d: {
        a: "bad"
      }
    };
    let result = dictWrapper_decode(json);
    if (result.TAG === "Ok") {
      t.fail("should have failed");
      return;
    }
    t.equal(result._0.path, ".d.a", "path should be .d.a");
  });
});

export {
  testEqual,
  inner_decode,
  outer_decode,
  arrayWrapper_decode,
  v_decode,
  pv_decode,
  tupleWrapper_decode,
  dictWrapper_decode,
}
/*  Not a pure module */
